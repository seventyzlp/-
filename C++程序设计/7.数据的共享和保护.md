无法访问到所有的信息，降低处理速度

# 标识符的作用域和可见性

## 作用域

- 作用域时一个标识符在程序正文中的有效区域
    - 循环内有效、主函数有效、全工程有效
- 作用域分类
    - 函数原型作用域：函数的参数、变量
        
        ```cpp
        double area(double radius); //声明函数时形式参数只在函数中，不能出现在程序正文中
        ```
        
    - 局部作用域
        - 函数的形参、在块中声明的标识符
        - 作用域自声明处起，限于块（从声明开始到}）中
        
        ```cpp
        void fun(int a){
        	int b = a;
        	if (b>0){
        		int c; 
        	}
        }
        ```
        
    - 类作用域：class
        - 包括类体和非内联成员函数的函数体
        - 在类作用域之外访问就需要类名、对象名、指针、引用来访问非静态类成员
    - 命名空间作用域
        - 解决类名、函数名的命名冲突
        - 自定义命名空间声明
    
    ```cpp
    namespace 名字{
    声明;
    }
    
    using namespace 名字;
    using 名字::标识符名字;//使用方法
    ```
    

## 可见性

- 从标识符引用的角度来看的概念
- 从内层作用域向外层作用域看时能看见什么
- 如果可见，就可以引用此标识符
- 如果在外层声明，在内层中没有同标识符的声明，那么在内层可见
- 两个嵌套的作用域如果有同名标识符，那么外层的在内层不可见

## 限定作用域的枚举类

```cpp
enum color { r,g,b}； // 不限定作用域
enum color2 {r,g,b}; //不可重复定义
enum class color2 {r ,g,b};// 限定作用域，就可以重新定义

//访问
color a = r; //全局作用域
color2 a2 = color2::red; //访问类的成员才能访问
```

## 全局变量和局部变量

可以直接加{}，然后定义生成局部变量空间

```cpp
int i;
void main(){
i = 5;//全局
{ int i;
	i = 7//局部
}
}
```

# 对象的生存期

对象产生（声明）到结束（ } )的时间就是生存期。在对象生存期内，对象将保持它的值，直到被更新为止。

构造函数→生成

析构函数→删除

经历的时间就是生存期

### 静态生存期

- 与程序运行期相同 main(){}全程
- 在文件作用域中声明的对象有这种生存期（main函数之外）
- 在函数内部声明需要加关键字 static
- 如果是在函数中的话，在重复调用时不会被重置

### 动态生存期

- 在哪创建，没有static的话，就是在哪个作用域内生存（局部生存期对象）
- 开始于程序执行到声明，结束于作用域}

# 类的静态成员

- 静态数据成员
    - static
    - 为类的所有成员共享，静态数据成员有静态生存期
    - 一般在类外初始化，要用：：指出所属的类
    - 静态常量可以在类内初始化
    
    ```cpp
    class A {
    static int a;
    }
    A::a = 1; //在类外初始化，看起来很全局的样子，在类内也不是不行
    ```
    
- 静态函数成员
    - 类外代码可以使用类名和作用域的操作符在调用静态成员函数
    - 静态成员函数主要用于处理类的静态数据成员，可以直接调用静态成员函数
    - 要用对象来访问非静态成员

# 类的友元

- 属性变量是private类型，在类的外部是不能用.访问的，要访问很麻烦
- 友元关系
    - 类主动声明自己的朋友类、朋友函数，特许访问本类数据
    - 友元可以用.访问
    - 适应外界同时需要多个对象的私有属性
- 可以破坏数据封装和数据隐藏的机制
- 通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息
- 尽量少用
- 友元函数
    - 在类声明中由friend修饰的非成员函数  friend.外部函数
- 友元类
    - 不是继承，但是有继承的效果
1. 非传递性：B-A B-C A<>C
2. 非继承性：子类不会继承友元关系
3. 单项性：A→B B!→A
4. 前向引用：先声明B，再定义B是A的友元，然后再在B的定义中使用A的东西。如果是有成员函数需要用到B的参数类型，那么也需要先声明B
    - 所有的类都先声明再使用
    - 如果需要在某个类定义之前需要引用这个类，就要前向引用声明
    - 前向引用声明只为程序引入了一个标识符，但具体声明在其他地方
    
    注意
    
    - 不是万能的
    - 在提供一个完整的 类的声明之前，不能声明类的对象，也不能在内联成员函数中使用该类的对象
    - 当使用前向引用声明时，只能使用被声明的符号，不能是类的细节

# 结构体

- 定义

```cpp
struct 结构体名字 {
公有成员;
private:
;
}
```

- 结构体是一种特殊形态的类
    - 类的缺省访问权限是private，结构体是public
    - 结构体的存在为了与C兼容
- 什么时候用
    - 定义上用来保存数据，不用来修改，只是访问
    - 习惯上把成员设置成公有，这样会更方便（？数据成员还是对象是公有）
- 全部数据成员为公有，并且没有构造函数、基类和虚函数那么可以直接 类型 变量 = {a,b,c}赋值

# 共享数据的保护

需要共享，但是不想被改变应该声明为常类型const，对于不改变对象状态的成员函数应该声明为常函数

## 常类型

- 常对象：必须初始化，不能被更新 const 类名 对象名

```cpp
class A {};
A const a(3,4) //常对象，不能被改变
```

- 常成员

```cpp
func() const;
class R {};
//调用时也要带const

//数据成员就加在数据声明符前面
const int b;
```

- 常引用
    - 声明引用时const就是常引用
    - 引用对象就不能被更新
    - 用常引用做形参，就不会意外修改实参的值

```cpp
const int &引用名;
```

- 常数组
- 常指针

## 匿名命名空间

namespace{

}

# 多文件结构和编译预处理命令

- 工程文件
    - 类声明文件.h（头文件）
        - 声明
    - 类实现文件.cpp
        - 定义、初始化
    - 类使用文件main（）在的cpp
- 使用工程来组合各种文件，分文件处理方便维护

## 外部变量

- 一个变量可以在别的cpp文件中使用，就是外部变量
- 文件作用域（main之外）中定义的变量默认是外部变量，在其他文件中如果要使用需要加entern关键字

## 标准C++库

- 输入输出
- 容器类和抽象数据类型
- 存储管理类
- 算法
- 错误处理
- 运行环境支持

## 编译预处理

- #include 将原文件嵌入
    - <>标准方式搜索，“”在当前目录搜索
- #define 宏定义 符号常量
- #undef 删除定义宏